import { PrettyWriter } from './writer';
import { Program } from '../ir/program';
import { IRObject } from '../ir/object';
import { toCamelCase, toPascalCase } from '../utils';
import { IRType, PrimitiveTypeName } from '../ir/type';

const PRIMITIVE_TYPE: Record<PrimitiveTypeName, string> = {
  uuid: 'UUID',
  i8: 'number',
  i16: 'number',
  i32: 'number',
  u8: 'number',
  u16: 'number',
  u32: 'number',
  f32: 'number',
  f64: 'number',
  bool: 'boolean',
  str: 'string',
};

export function generateTypescriptClient(program: Program): string {
  const writer = new PrettyWriter();

  writer.write('// VOSS AUTOGENERATED FILE, DO NOT MODIFY.\n');
  writer.write(`import {
    Builder,
    EnumCase,
    Reader,
    Struct
  } from './runtime';\n\n`);
  writer.write(`type UUID = string;\n`);

  program.getRPC();

  for (const object of program.getObjects()) {
    generateObjectClass(writer, object);
  }

  return writer.getSource();
}

function generateObjectClass(writer: PrettyWriter, object: IRObject): void {
  writer.write(`export class ${object.name} implements Struct {\n`);
  writer.write(
    `readonly _maxElementAlignment = ${object.getMaxElementAlignment()};\n`
  );
  writer.write(`readonly _size = ${object.getSize()};\n`);

  writer.write('constructor(\n');
  writer.indent();
  writer.write('readonly $session: VossSession,\n');
  for (const field of object.getFields()) {
    writer.write('private __' + toCamelCase(field.name) + ': ');
    writer.write(getObjectFieldPrivateType(field.type) + ',\n');
  }
  writer.dedent();
  writer.write(') {}\n');

  // Define the property getters.
  for (const field of object.getFields()) {
    const name = 'this.__' + toCamelCase(field.name);
    if (field.type.isRootObject) {
      writer.write('fetch' + toPascalCase(field.name) + '():');
      writer.write(` Promise<${field.type.asObject().name}> {\n`);
      writer.write(`return this.$session.fetchObjectByUUID(${name});\n`);
      writer.write('}\n');
    } else {
      writer.write('get ' + toCamelCase(field.name) + '() {\n');
      writer.write(`return ${name};\n`);
      writer.write('}\n');
    }
  }

  // <-- Generate the Serialize method.
  writer.write('_serialize(builder: Builder) {\n');
  for (const field of object.getFields()) {
    const name = 'this.__' + toCamelCase(field.name);
    const offset = field.getOffset();
    const writeFn: string = field.type.isRootObject
      ? 'uuid'
      : field.type.isObject
      ? 'struct'
      : field.type.isEnum
      ? 'enum'
      : field.type.asPrimitiveName();
    writer.write(`builder.${writeFn}(${offset}, ${name});\n`);
  }
  writer.write('}\n');
  // Generate the Serialize method. -->

  // <-- Generate the Deserialize static method.
  writer.write('static deserialize(session: VossSession, reader: Reader) {\n');
  writer.write(`return new ${object.name}(\n`);
  writer.indent();
  writer.write('session,\n');
  for (const field of object.getFields()) {
    const offset = field.getOffset();
    const readFn: string = field.type.isRootObject
      ? 'uuid'
      : field.type.isObject
      ? 'struct'
      : field.type.isEnum
      ? 'enum'
      : field.type.asPrimitiveName();
    writer.write(`reader.${readFn}(${offset}),\n`);
  }
  writer.dedent();
  writer.write(');\n}\n');
  // Generate the Deserialize static method. -->

  writer.write('}\n');
}

function getObjectFieldPrivateType(type: IRType): string {
  if (type.isPrimitive) {
    return PRIMITIVE_TYPE[type.asPrimitiveName()];
  }

  if (type.isStructure) {
    return type.asObject().name;
  }

  if (type.isRootObject) {
    return 'UUID';
  }

  if (type.isEnum) {
    return type.asEnum().name;
  }

  throw new Error('Not implemented.');
}
