import { PrettyWriter } from './writer';
import { Program } from '../ir/program';
import { IRObject, IRObjectField } from '../ir/object';
import {
  toCamelCase,
  toPascalCase,
  getObjectFieldPrivateType,
  flatten,
} from '../utils';
import { PrimitiveTypeName } from '../ir/type';
import { IREnum } from '../ir/enum';
import * as pluralize from 'pluralize';

const PRIMITIVE_TYPE: Record<PrimitiveTypeName, string> = {
  hash16: 'HASH16',
  hash20: 'HASH20',
  i8: 'number',
  i16: 'number',
  i32: 'number',
  u8: 'number',
  u16: 'number',
  u32: 'number',
  f32: 'number',
  f64: 'number',
  bool: 'boolean',
  str: 'string',
};

export function generateTypescriptClient(program: Program): string {
  const writer = new PrettyWriter();

  writer.write('// VOSS AUTOGENERATED FILE, DO NOT MODIFY.\n');
  writer.write(`import * as voss from './runtime';

  type HASH16 = string;
  type HASH20 = string;
\n`);

  program.getRPC();

  for (const object of program.getObjects()) {
    generateObject(writer, object);
  }

  for (const irEnum of program.getEnums()) {
    generateEnum(writer, irEnum);
  }

  generateRPC(writer, program);

  return writer.getSource();
}

function generateObjectDataInterface(
  writer: PrettyWriter,
  object: IRObject
): void {
  const name = toPascalCase(object.name) + '$Data';
  writer.write(`export interface ${name} {\n`);
  for (const field of object.getFields()) {
    writer.write(toCamelCase(field.name) + ': ');
    writer.write(getObjectFieldPrivateType(PRIMITIVE_TYPE, field.type) + ',\n');
  }
  writer.write(`}\n`);
}

function generateObject(writer: PrettyWriter, object: IRObject): void {
  generateObjectDataInterface(writer, object);

  const maxAlign = object.getMaxElementAlignment();

  // Build the proper class deceleration.
  const name = toPascalCase(object.name);
  writer.write(`export class ${toPascalCase(object.name)} `);
  if (object.isRoot) writer.write(`extends voss.ObjectBase<${name}$Data> `);
  writer.write(`implements voss.Struct {\n`);

  // The data for the serialization.
  writer.write(`static readonly maxElementAlignment = ${maxAlign};\n`);
  writer.write(`static readonly size = ${object.getSize()};\n`);

  // ... Build the constructor.
  generateObjectClassConstructor(writer, object);

  for (const field of object.getFields()) {
    generateObjectPropertyGetter(writer, field);
    if (field.name !== 'uuid') {
      generateObjectPropertySetter(writer, field);
    }
  }

  // The compare function.
  generateEqualMethod(writer, object);

  // The serialization methods.
  generateSerializeMethod(writer, object);
  generateDeserializeMethod(writer, object);

  writer.write('}\n');
}

function generateObjectClassConstructor(
  writer: PrettyWriter,
  object: IRObject
): void {
  const dataInterfaceName = toPascalCase(object.name) + '$Data';
  writer.write(`constructor(protected data: ${dataInterfaceName}) {\n`);
  if (object.isRoot) {
    writer.write('super();\n');
  }
  writer.write(`}\n`);
}

function generateObjectPropertyGetter(
  writer: PrettyWriter,
  field: IRObjectField
): void {
  const name = 'this.data.' + toCamelCase(field.name);
  const fieldName = toPascalCase(field.name);
  if (field.type.isRootObject) {
    const returnName = toPascalCase(field.type.asObject().name);
    writer.write('fetch' + fieldName + '(session: VossSession):');
    writer.write(` Promise<${returnName} | undefined> {\n`);
    writer.write(`return session.fetchObjectByUUID(${name});\n`);
    writer.write('}\n');
  } else {
    writer.write('get' + toPascalCase(field.name) + '() {\n');
    writer.write(`return ${name};\n`);
    writer.write('}\n');
  }
}

function generateObjectPropertySetter(
  writer: PrettyWriter,
  field: IRObjectField
): void {
  const object = field.getOwner();
  const valueType = field.type.isPrimitive
    ? PRIMITIVE_TYPE[field.type.asPrimitiveName()]
    : toPascalCase(field.type.name);
  const valueGetter = field.type.isRootObject ? `.getUuid()` : '';

  if (object.isRoot) {
    const fieldName = toPascalCase(field.name);
    const objectName = toPascalCase(object.name);
    const caseName = 'Object' + objectName + 'Set' + fieldName;
    const req = '_' + caseName + 'Request';
    writer.write(`
set${fieldName}(session: VossSession, value: ${valueType}): Promise<void> {
  this.data.${toCamelCase(field.name)} = value${valueGetter};
  this.emitChange();
  return session.sendRequest((replyId, timestamp) => ({
      type: _RPCMessage$Type.${caseName},
      value: new ${req}({
        replyId,
        timestamp,
        target: this.data.uuid,
        current: this.data.${toCamelCase(field.name)},
        next: value${valueGetter},
      })
  }));
}\n`);
    return;
  }

  writer.write(
    `set${toPascalCase(field.name)}(value: ${valueType}): ${object.name} {\n`
  );
  writer.write(
    `return new ${object.name}({...this.data, ${toCamelCase(
      field.name
    )}: value${valueGetter}});\n`
  );
  writer.write('}\n');
}

function generateEqualMethod(writer: PrettyWriter, object: IRObject): void {
  const name = toPascalCase(object.name);
  const fields = [...object.getFields()];
  writer.write(`equal(other: ${name}): boolean {
    if (this.data === other.data) return true;
    return ${
      fields.length === 0
        ? 'true'
        : fields
            .sort((a, b) => {
              if (a.type.isPrimitive) return -1;
              if (b.type.isPrimitive) return 1;
              return 0;
            })
            .map((field) => {
              const name = toCamelCase(field.name);
              if (field.type.isPrimitive || field.type.isRootObject) {
                return `this.data.${name} === other.data.${name}`;
              }

              if (field.type.isObject) {
                return `this.data.${name}.equal(other.data.${name})`;
              }

              if (field.type.isEnum) {
                return `voss.enumEqual(this.data.${name}, other.data.${name})`;
              }

              throw new Error('Not implemented.');
            })
            .join(' &&\n')
    };
  }\n`);
}

function generateSerializeMethod(writer: PrettyWriter, object: IRObject): void {
  writer.write('serialize(builder: voss.Builder) {\n');
  for (const field of object.getFields()) {
    const name = 'this.data.' + toCamelCase(field.name);
    const offset = field.getOffset();
    const writeFn: string = field.type.isRootObject
      ? 'hash16'
      : field.type.isObject
      ? 'struct'
      : field.type.isEnum
      ? 'enum'
      : field.type.asPrimitiveName();
    writer.write(`builder.${writeFn}(${offset}, ${name});\n`);
  }
  writer.write('}\n');
}

function generateDeserializeMethod(
  writer: PrettyWriter,
  object: IRObject
): void {
  writer.write('static deserialize(reader: voss.Reader) {\n');
  writer.write(`return new ${object.name}({\n`);
  writer.indent();
  for (const field of object.getFields()) {
    writer.write(
      toCamelCase(field.name) + ': ' + getDeserializeField(field) + ',\n'
    );
  }
  writer.dedent();
  writer.write('});\n}\n');
}

function getDeserializeField(field: IRObjectField): string {
  const offset = field.getOffset();
  const readFn: string = field.type.isRootObject
    ? 'hash16'
    : field.type.isObject
    ? 'struct'
    : field.type.isEnum
    ? 'enum'
    : field.type.asPrimitiveName();
  const deserializeFn = field.type.isStructure
    ? ', ' + field.type.asObject().name + '.deserialize'
    : field.type.isEnum
    ? ', ' + field.type.asEnum().name + '$DeserializerMap'
    : '';
  return `reader.${readFn}(${offset}${deserializeFn})`;
}

function generateEnum(writer: PrettyWriter, irEnum: IREnum): void {
  generateEnumTypeEnum(writer, irEnum);
  generateEnumCases(writer, irEnum);
  generateEnumDeserializer(writer, irEnum);
}

function generateEnumTypeEnum(writer: PrettyWriter, irEnum: IREnum): void {
  writer.write(`export const enum ${irEnum.name}$Type {\n`);
  for (const enumCase of irEnum.getCases()) {
    writer.write(`${enumCase.name} = ${enumCase.value},\n`);
  }
  writer.write('}\n');
}

function generateEnumCases(writer: PrettyWriter, irEnum: IREnum): void {
  const typeEnumName = irEnum.name + '$Type';
  writer.write(`export type ${irEnum.name} =\n`);
  writer.indent();
  for (const enumCase of irEnum.getCases()) {
    writer.write(
      `| voss.EnumCase<${typeEnumName}.${enumCase.name}, ${enumCase.type.name}>\n`
    );
  }
  writer.write(';\n');
  writer.dedent();
}

function generateEnumDeserializer(writer: PrettyWriter, irEnum: IREnum): void {
  const constName = irEnum.name + '$DeserializerMap';
  const typeEnumName = irEnum.name + '$Type';
  writer.write(
    `export const ${constName}: Record<${typeEnumName}, voss.DeserializeFn<any>> = {\n`
  );
  for (const enumCase of irEnum.getCases()) {
    writer.write(
      `[${typeEnumName}.${enumCase.name}]: ${enumCase.type.name}.deserialize,\n`
    );
  }
  writer.write('}\n');
}

function generateSessionClass(writer: PrettyWriter, program: Program): void {
  writer.write(`export class VossSession extends voss.VossSessionBase<_RPCMessage> {
  protected objects = new Map<string, voss.ObjectBase<any>>();
  protected deserializeMap = _RPCMessage$DeserializerMap;
  ${[...program.getObjects()]
    .filter((obj) => obj.isRoot)
    .map((obj) => {
      const name = 'viewAll' + pluralize(toPascalCase(obj.name));
      return `readonly ${name};`;
    })
    .join('\n')}

  async fetchObjectByUUID(uuid: string): Promise<any> {
    if (this.objects.has(uuid)) {
      return this.objects.get(uuid);
    }

    await this.sendRequest((replyId) => ({
        type: _RPCMessage$Type.FetchByUUID,
        value: new _FetchByUUIDRequest({ replyId, uuid }),
    }));

    return this.objects.get(uuid);
  }

  protected createClockRequest(timestamp: number): _RPCMessage {
    return {
      type: _RPCMessage$Type.Clock,
      value: new _ClockData({ timestamp }),
    };
  }

  protected CAS(uuid: string, field: string, current: any, next: any): void {
    const object = this.objects.get(uuid);
    if (!object) return;
    if (object.CAS(field, current, next)) return;
    // Conflict.
    throw new Error('Cannot handle conflict.');
  }

  protected onMessage(message: _RPCMessage): void {
    switch (message.type) {
      case _RPCMessage$Type.Reply:
        this.receivedReply(message.value.getReplyId());
        break;
      case _RPCMessage$Type.Clock:
        this.receivedTime(message.value.getTimestamp());
        break;
      ${flatten(
        [...program.getObjects()]
          .filter((object) => object.isRoot)
          .map((object) => {
            const objectName = toPascalCase(object.name);
            return [...object.getFields()]
              .filter((field) => field.name !== 'uuid')
              .map((field) => {
                const fieldName = toPascalCase(field.name);
                const caseName = 'Object' + objectName + 'Set' + fieldName;
                const cf = toCamelCase(field.name);
                return `case _RPCMessage$Type.${caseName}:
              this.CAS(
                message.value.getTarget(),
                '${cf}',
                message.value.getCurrent(),
                message.value.getNext()
              );
              break;`;
              });
          })
      ).join('\n')}
    }
  }
}
`);
}

function generateRPC(writer: PrettyWriter, program: Program): void {
  writer.write('export namespace RPC {\n');

  const rpc = program.getRPC();

  for (const message of rpc.getCases()) {
    const object = message.type.asObject();
    generateObject(writer, object);
  }

  generateEnum(writer, rpc);
  generateSessionClass(writer, program);

  writer.write('}\n');
}