import { plural } from 'pluralize';
import { Writer } from './writer';
import * as IR from './ir';

const TypeNames: Record<IR.InternalTypeName, string> = Object.freeze({
  i8: 'number',
  i16: 'number',
  i32: 'number',
  u8: 'number',
  u16: 'number',
  u32: 'number',
  f32: 'number',
  f64: 'number',
  string: 'string',
  bool: 'boolean',
});

export class TypeScriptBackend {
  constructor(protected writer: Writer, protected program: IR.Program) {
    this.genHeader();
    this.genInterfaces();
    this.genSessionClass();
    this.genRPC();
  }

  write(chunk: string) {
    this.writer.write(chunk);
  }

  genHeader() {
    this.write(`// THIS FILE WAS GENERATED BY VOSS, DO NOT MODIFY.

export type UUID = string;

export interface EnumCase<T, V> {
  readonly session: Session;
  readonly type: T;
  readonly value: V;
}

export type LazyReference<T> = Promise<T | undefined>;

export interface ChangeNotifier {
  on(event: 'change', cb: () => void): void;
  off(event: 'change', cb: () => void): void;
}

export interface ReadonlyView<T> extends ChangeNotifier {
  readonly members: ReadonlyArray<T>;
}

export interface ReadonlyLazyView<T> extends ReadonlyView<T> {
  readonly isLoaded: boolean;
  load(): Promise<void>;
}

export class IChangeNotifier implements ChangeNotifier {
  private readonly listeners = new Set<() => void>();

  on(event: 'change', cb: () => void): void {
    if (event !== 'change') {
      return;
    }

    this.listeners.add(cb);
  }

  off(event: 'change', cb: () => void): void {
    if (event !== 'change') {
      return;
    }

    this.listeners.delete(cb);
  }

  emitChange(): void {
    for (const listener of this.listeners) {
      listener();
    }
  }
}

`);
  }

  genInterfaces() {
    for (const declaration of this.program.structures) {
      this.genStructClass(declaration);
    }
    for (const declaration of this.program.enums) {
      this.genOneofInterface(declaration);
    }
    for (const declaration of this.program.objects) {
      this.genObjectClass(declaration);
    }
  }

  genOneofInterface(declaration: IR.Oneof) {
    this.write(`export const enum ${declaration.name}$Type {\n`);
    for (const data of declaration.cases) {
      this.write(data.name + ' = ' + data.value + ',\n');
    }
    this.write(`}\n`);

    this.write(`export type ${declaration.name} =\n`);
    this.writer.indent();
    for (let i = 0; i < declaration.cases.length; ++i) {
      const data = declaration.cases[i];
      this.write(`| EnumCase<${declaration.name}$Type.${data.name}, `);
      this.genType(data.type);
      this.write(i === declaration.cases.length - 1 ? '>;\n' : '>\n');
    }
    this.writer.dedent();
  }

  genStructClass(declaration: IR.Structure) {
    this.write(`export class ${declaration.name} {\n`);
    this.write(`constructor(\n`);
    this.writer.indent();
    this.write('private readonly session$: Session,\n');

    for (const field of declaration.fields) {
      if (field.type.kind === IR.TypeKind.RootObjectReference) {
        this.write('private readonly ' + field.name + '$UUID: UUID,\n');
        continue;
      }
      this.write('readonly ' + field.name + ': ');
      this.genType(field.type);
      this.write(',\n');
    }

    this.writer.dedent();
    this.write(`) {}\n`);

    for (const field of declaration.fields) {
      if (field.type.kind !== IR.TypeKind.RootObjectReference) {
        continue;
      }

      this.write(
        `load${upper(field.name)}(): LazyReference<${
          field.type.object.name
        }> {
          return this.session$.fetchObjectByUUID(this.${field.name}$UUID);
        }\n`
      );
    }

    this.write(`}\n`);
  }

  genObjectClass(declaration: IR.RootObject) {
    this.write(`export class ${declaration.name} extends IChangeNotifier {\n`);
    this.write(`constructor(\n`);
    this.writer.indent();
    this.write('private readonly session$: Session,\n');
    this.write('readonly uuid$: UUID,\n');

    for (const data of declaration.fields) {
      if (data.type.kind === IR.TypeKind.RootObjectReference) {
        this.write('private readonly ' + data.name + '$UUID: UUID,\n');
        continue;
      }
      this.write('readonly ' + data.name + ': ');
      this.genType(data.type);
      this.write(',\n');
    }

    this.writer.dedent();
    this.write(`) { super(); }\n`);

    for (const data of declaration.fields) {
      if (data.type.kind !== IR.TypeKind.RootObjectReference) {
        continue;
      }

      this.write(
        `load${upper(data.name)}(): LazyReference<${
          data.type.object.name
        }> {
          return this.session$.fetchObjectByUUID(this.${data.name}$UUID);
        }\n`
      );
    }

    this.write(`}\n`);
  }

  genSessionClass() {
    this.write(`
export class Session {
  private objects = new Map<UUID, any>();

  constructor() {}

  async fetchObjectByUUID(uuid: UUID): LazyReference<any> {
    // TODO(qti3e) Send a request to server.
    return this.objects.get(uuid);
  }
`);

    for (const object of this.program.objects) {
      this.write(`create${upper(object.name)}() {\n`)
      this.write('}\n');
    }

    for (const object of this.program.objects) {
      if (object.viewedIn.length > 0) {
        continue;
      }

      this.write(`async fetch${plural(upper(object.name))}() {\n`)
      this.write('}\n');
    }

    this.write('}\n');
  }

  genRPC() {
    this.genOneofInterface(this.program.rpc);
  }

  genType(type: IR.Type, open = 'readonly [', close = ']') {
    if (type.kind === IR.TypeKind.InternalPrimitive) {
      this.write(TypeNames[type.name]);
    } else if (type.kind == IR.TypeKind.OneofReference) {
      this.write(type.oneof.name);
    } else if (type.kind === IR.TypeKind.Struct) {
      this.write(type.struct.name);
    } else if (type.kind === IR.TypeKind.RootObjectReference) {
      this.write('UUID');
    } else {
      this.write(open);
      for (let i = 0; i < type.members.length; ++i) {
        if (i > 0) {
          this.write(', ');
        }
        this.genType(type.members[i]);
      }
      this.write(close);
    }
  }
}

function upper(name: string) {
  if (name.length === 0) {
    return '';
  }

  return name[0].toUpperCase() + name.slice(1);
}
