// VOSS AUTOGENERATED FILE, DO NOT MODIFY.
import * as voss from './runtime';

type HASH16 = string;
type HASH20 = string;

<!-- ****************************** OBJECTS ****************************** -->
<container *for="let object in objects">
  <!-- The $Data interface -->
  <interface [name]="object.pascalCase + '$Data'">
    <interface-member
      *for="let field in object.getFields | call"
      [name]="field.camelCase"
      [type]="field.type | type" />
  </interface>

  <!-- ****************************** ROOT OBJECTS ****************************** -->
  <class
    *if="object.isRoot"
    [name]="object.pascalCase"
    [extend]="object.pascalCase | objectBase"
    implement="voss.Struct"
    exported>

    constructor(protected data: {{ object.pascalCase }}$Data) {
      super();
    }

    <!-- View Containers (for viewed objects) -->
    <container *for="let field in object.getFields | call" *if="field.isViewed">
      <property
        [name]="field.camelCase + 'View'"
        [default]="field | fieldViewMap"
        static readonly />
      
      <method [name]="'get' + field.pascalCase + 'ViewFor'" static>
        <parameter name="session" type="RPC.VossSession" />
        <parameter name="object" type="HASH16" />
        const views = voss.getOrInsert({{object.pascalCase}}.{{field.camelCase}}View, session, () => new Map());
        return voss.getOrInsert(views, object, () => new voss.View(async () => {
          await session.sendRequest((replyId: number) => ({
            type: RPC.RPCMessage$Type.{{field.rpcGetFetchViewCase | call}},
            value: new RPC.{{field.rpcGetFetchViewMsg | call}}({
              replyId,
              host: object
            })
          }))
        }));
      </method>
    </container>

    <!-- View Accessors -->
    <container *for="let view in object.getViews | call">
      <method [name]="'view' + view.pascalCase" [type]="'voss.ReadonlyView<' + view.target.pascalCase + '>'">
        <parameter name="session" type="RPC.VossSession" />
        return {{ view.target.pascalCase }}.get{{view.via.pascalCase}}ViewFor(session, this.getUuid());
      </method>
    </container>

    <!-- View init -->
    <method name="init">
      <parameter name="session" type="RPC.VossSession" />
      <container *for="let field in object.getFields | call" *if="field.isViewed">
        {{object.pascalCase}}.get{{field.pascalCase}}ViewFor(session, this.data.{{field.camelCase}}).add(this);
      </container>
    </method>

    <method name="updated">
      <parameter name="session" type="RPC.VossSession" />
      <parameter name="key" />
      <parameter name="prev" />
      switch (key) {
        <container *for="let field in object.getFields | call" *if="field.isViewed">
          case "{{field.camelCase}}":
            {{object.pascalCase}}.get{{field.pascalCase}}ViewFor(session, prev).remove(this);
            {{object.pascalCase}}.get{{field.pascalCase}}ViewFor(session, this.data.{{field.camelCase}}).add(this);
            break;
        </container>
      }
    </method>

    <!-- Getter/Setters -->
    <container *for="let field in object.getFields | call">
      <render template="object-getter" />

      <!-- Setter -->
      <method
        *if="field.name != 'uuid'"
        [name]="'set' + field.pascalCase">
        <parameter name="session" type="RPC.VossSession" />
        <parameter name="value" [type]="field | fieldSetterType" />
        const current = this.data.{{field.camelCase}};
        const next = this.data.{{field.camelCase}} = {{ field | fieldSetterValue }};
        this.emitChange();
        return session.sendRequest((replyId, timestamp) => ({
            type: RPC.RPCMessage$Type.{{field.rpcGetSetCase | call}},
            value: new RPC.{{field.rpcGetSetMsg | call}}({
              replyId,
              timestamp,
              target: this.data.uuid,
              current, next
            })
        }));
      </method>
    </container>

    <render template="object-base" />
  </class>

  <!-- ****************************** SREUCTURE ****************************** -->
  <render template="object-struct" *if="object.isRoot != true" />
</container>

<!-- ****************************** ENUMS ****************************** -->
<render *for="let enum in enums" template="voss-enum" />

<!-- ****************************** RPC ****************************** -->
export namespace RPC {
<with-indent value="1">

  <container *for="let message in rpc.getCases | call">
    <bind name="object" [value]="message.type.asObject | call" />

    <!-- The $Data interface -->
    <interface [name]="object.pascalCase + '$Data'">
      <interface-member
        *for="let field in object.getFields | call"
        [name]="field.camelCase"
        [type]="field.type | type"
        readonly />
    </interface>

    <class
      [name]="object.pascalCase"
      implement="voss.Struct"
      exported>
      constructor(readonly data: {{ object.pascalCase }}$Data) {}
      <render template="object-base" />
    </class>
  </container>

  <container>
    <bind name="enum" [value]="rpc" />
    <render template="voss-enum" />
  </container>

  export class VossSession extends voss.VossSessionBase&lt;RPCMessage&gt; {
    protected hostID?: number;
    protected objects = new Map&lt;string, voss.ObjectBase&lt;any, VossSession&gt;&gt;();
    protected deserializeMap = RPCMessage$DeserializerMap;

    async fetchObjectByUUID(uuid: string): Promise&lt;any&gt; {
      if (this.objects.has(uuid)) {
        return this.objects.get(uuid);
      }

      await this.sendRequest((replyId) => ({
          type: RPCMessage$Type.FetchByUUID,
          value: new FetchByUUIDMessage({ replyId, uuid }),
      }));

      return this.objects.get(uuid);
    }

    protected createClockRequest(timestamp: number): RPCMessage {
      return {
        type: RPCMessage$Type.Clock,
        value: new ClockMessage({ timestamp }),
      };
    }

    protected getHostId(): number {
      if (this.hostID === undefined) throw new Error('Host ID is not yet initialized.');
      return this.hostID;
    }

    protected CAS(uuid: string, field: string, current: any, next: any): void {
      const object = this.objects.get(uuid);
      if (!object) return;
      if (object.CAS(this, field, current, next)) return;
      // Conflict.
      throw new Error('Cannot handle conflict.');
    }

    protected onMessage(message: RPCMessage): void {
      switch (message.type) {
        case RPCMessage$Type.Reply:
          this.receivedReply(message.value.data.replyId);
          break;
        case RPCMessage$Type.Clock:
          this.receivedTime(message.value.data.timestamp);
          break;
        case RPCMessage$Type.HostID:
          this.hostID = message.value.data.value;
          break;
      }
    }
  }

</with-indent>
}

<!-- ****************************** TEMPLATES ****************************** -->

<!-- This template implements serialization and equal -->
<template name="object-base">
  <!-- Size and Alignment -->
  <property
    name="maxElementAlignment"
    [default]="object.getMaxElementAlignment | call"
    static readonly />

  <property
    name="size"
    [default]="object.getSize | call"
    static readonly />
  
  <method name="equal">
    <parameter name="other" [type]="object.pascalCase" />
    return (
      <line
        *indent="1"
        *for="let field in object.getFields | call | sortForEqual"
        [value]="(field | equal) + ' &&'" />
      <line *indent="1" value='false' />
    );
  </method>

  <!-- The serializer -->
  <method name="serialize">
    <parameter name="builder" type="voss.Builder" />
    <container *for="let field in object.getFields | call">
      builder.{{field.type | encoder}}({{field.getOffset | call}}, this.data.{{field.camelCase}});
    </container>
  </method>

  <!-- The deserializer -->
  <method name="deserialize" static>
    <parameter name="reader" type="voss.Reader" />
    return new {{object.pascalCase}} ({
    <container *for="let field in object.getFields | call" *indent="1">
      <container *if="field.type.isPrimitive || field.type.isRootObject">
      {{field.camelCase}}: reader.{{field.type | encoder}}({{field.getOffset | call}}),
      </container>
      <container *if="field.type.isStructure">
        {{field.camelCase}}: reader.{{field.type | encoder}}({{field.getOffset | call}}, {{field.type.pascalCase}}.deserialize),
      </container>
      <container *if="field.type.isEnum">
        {{field.camelCase}}: reader.{{field.type | encoder}}({{field.getOffset | call}}, {{field.type.pascalCase}}$DeserializerMap),
      </container>
    </container>
    });
  </method>
</template>

<template name="object-getter">
    <!-- For Views we use fecthXXX -->
    <method
      *if="field.type.isRootObject"
      [name]="'fetch' + field.pascalCase">
      <parameter name="session" type="RPC.VossSession" />
      return session.fetchObjectByUUID(this.data.{{field.camelCase}});
    </method>

    <!-- Primitive/Struct types have getters -->
    <method
      *if="field.type.isRootObject != true"
      [name]="'get' + field.pascalCase">
      return this.data.{{field.camelCase}};
    </method>
</template>

<template name="object-struct">
  <class
    [name]="object.pascalCase"
    implement="voss.Struct"
    exported>

    constructor(protected data: {{ object.pascalCase }}$Data) {}

    <!-- Getter/Setters -->
    <container *for="let field in object.getFields | call">
      <render template="object-getter" />

      <!-- Root object type setter -->
      <method
        *if="field.type.isRootObject"
        [name]="'set' + field.pascalCase">
        <parameter name="value" [type]="field.type | type" />
        return new {{object.pascalCase}}({ ...this.data, {{field.camelCase}}: value.getUuid() });
      </method>

      <!-- Primitive/Struct type setter -->
      <method
        *if="field.type.isRootObject != true"
        [name]="'set' + field.pascalCase">
        <parameter name="value" [type]="field.type | type" />
        return new {{object.pascalCase}}({ ...this.data, {{field.camelCase}}: value });
      </method>
    </container>

    <render template="object-base" />
  </class>
</template>

<!-- ENUM TEMPLATE -->
<template name="voss-enum">
  <enum [name]="enum.pascalCase + '$Type'" exported>
    <enum-member
      *for="let member in enum.getCases | call"
      [name]="member.pascalCase"
      [value]="member.value"
      exported/>
  </enum>
  export type {{ enum.pascalCase }} =
  <line
    *for="let member in enum.getCases | call"
    *indent="1"
    [value]="member | enumMember" />
  <line *indent="1" value=";" />
  <line value=" " />
  export const {{ enum.pascalCase + '$DeserializerMap'  }}: {{ enum | enumDeserializerType }} = {
    <line
      *for="let member in enum.getCases | call"
      *indent="1"
      [value]="member | enumDeserializer" />
  <line value="}" />
</template>