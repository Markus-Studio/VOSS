// THIS FILE WAS GENERATED BY VOSS, DO NOT MODIFY.
export type UUID = string;

export interface EnumCase<T, V> {
  readonly session: Session;
  readonly type: T;
  readonly value: V;
}
export type LazyReference<T> = Promise<T | undefined>;

export interface ChangeNotifier {
  on(event: 'change', cb: () => void): void;
  off(event: 'change', cb: () => void): void;
}

export interface ReadonlyView<T> extends ChangeNotifier {
  readonly members: ReadonlyArray<T>;
}

export interface ReadonlyLazyView<T> extends ReadonlyView<T> {
  readonly isLoaded: boolean;
  load(): Promise<void>;
}

export class IChangeNotifier implements ChangeNotifier {
  private readonly listeners = new Set<() => void>();

  on(event: 'change', cb: () => void): void {
    if (event !== 'change') {
      return;
    }
    this.listeners.add(cb);
  }

  off(event: 'change', cb: () => void): void {
    if (event !== 'change') {
      return;
    }
    this.listeners.delete(cb);
  }

  emitChange(): void {
    for (const listener of this.listeners) {
      listener();
    }
  }
}

export class A {
  constructor(
    private readonly session$: Session,
    private readonly ref$UUID: UUID,
    readonly x: number,
    readonly p: string,
    readonly u: boolean,
    readonly tuple: readonly [number, number],
  ) {}

  loadRef(): LazyReference<T> {
    return this.session$.fetchObjectByUUID(this.ref$UUID);
  }
}

export class RPC$ClockData {
  constructor(
    private readonly session$: Session,
    readonly timestamp: number,
  ) {}
}

export class T extends IChangeNotifier {
  constructor(
    private readonly session$: Session,
    readonly uuid$: UUID,
  ) { super(); }
}

export class Session {
  private objects = new Map<UUID, any>();
  constructor() {}

  async fetchObjectByUUID(uuid: UUID): LazyReference<any> {
    // TODO(qti3e) Send a request to server.
    return this.objects.get(uuid);
  }

  createT() {
  }

  async fetchTS() {
  }
}

export const enum RPCMessage$Type {
  clock = 1,
}
export type RPCMessage =
  | EnumCase<RPCMessage$Type.clock, RPC$ClockData>;